# Redis  
1.[Redis支持哪几种基本数据类型](#redis支持哪几种基本数据类型)  
2.[你还了解redis支持哪些特殊数据类型及应用场景](#redis支持哪些特殊数据类型及应用场景)  
3.[什么是缓存穿透、缓存击穿、缓存雪崩及解决方案](#什么是缓存穿透)   
4.[什么是Redis持久化,Redis有哪几种持久化方式,有啥优缺点](#什么是Redis持久化)   
5.[单线程Redis为什么这么快](#单线程redis为什么这么快)  
6.[Memcached与Redis的区别有哪些](#Memcached与Redis的区别有哪些)  
7.[Redis内部数据结构有哪些](#Redis内部数据结构有哪些)   
8.[Redis内存淘汰策略](#Redis内存淘汰策略)    
9.[redis常见性能问题和解决方案](#Redis常见性能问题和解决方案)




## Redis支持哪几种基本数据类型  
Redis支持五种类型：string（字符串）,hash（哈希）,list（列表）,set（集合）及zset(sorted set：有序集合)。  

### string 
格式：  
set name value  
get name  
string类型是Redis最基本的数据类型，一个键最大能存储512MB。  

### hash 
格式:   
hmset name  key1 value1 key2 value2  
hget name key1  
hgetall name  
hash特别适合用于存储对象。  

### list  
格式:   
lpush  name  value1  头部添加元素  
rpush  name  value2  尾部添加元素  
lpop name 移出并获取列表的第一个元素
rpop name 移除列表的最后一个元素，返回值为移除的元素。  
lrange name  0 1   获取列表指定范围内的元素  
list是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）

### set  
格式:   
sadd  name  value1  
smembers name  返回集合中的所有成员  
set是string类型的无序集合。
set是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。   
set内部实现是一个value永远为null的HashMap，实际就是通过hash的方式快速排重的。 

### zset  
格式:  
zadd  name score value  
zset 和 set 一样也是string类型元素的集合,且不允许重复的成员(value)。
不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
zset的成员(value)是唯一的,但分数(score)却可以重复。

## Redis支持哪些特殊数据类型及应用场景  
Redis中的四种特殊的数据结构Bitmap(位图),BloomFilter（布隆过滤器）,GeoHash,HyperLogLog。  
### bitmap  
bitmap底层就是string，也可以说 string底层就是bitmap。  
应用场景：统计一段时间内用户的在线天数/打卡次数  
### bloomFilter  
bloom Filter是一个包含m位的位数组，每一位都置为0。  
应用场景：爬取网站去重，垃圾邮件过滤，缓存穿透  
### geoHash  
geoHash 其实就是一个zset.  
使用Redis 的 Geo 数据结构，它们将全部放在一个 zset 集合中。在 Redis 的集群环境中，集合 可能会从一个节点迁移到另一个节点，如果单个 key 的数据过大，会对集群的迁移工作造成 较大的影响，在集群环境中单个 key 对应的数据量不宜超过 1M，否则会导致集群迁移出现 卡顿现象，影响线上服务的正常运行。
所以，这里建议 Geo 的数据使用单独的 Redis 实例部署，不使用集群环境。  
应用场景：附近的人,附近的公司  
### hyperLogLog  
hyperLogLog使用极少的内存统计巨量的数据，计算存在一定的误差。  
应用场景：统计网页的UV（浏览用户数量）

## 什么是缓存穿透、缓存击穿、缓存雪崩及解决方案<span id="什么是缓存穿透"></span>  
### 缓存穿透  
缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，就会对后端系统造成很大的压力。  
解决方案：  
1.对查询结果为空的情况也进行缓存，如可以将key-value对应为key-null。  
2.对一定不存在的key进行过滤，如使用redis的布隆过滤器。  
### 缓存击穿  
缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大。  
解决方案：   
1.热点数据永不过期  
2.对获取某个key数据值加互斥锁，一个线程去获取数据并缓存，其他都读缓存。
### 缓存雪崩  
缓存雪崩是指缓存中不同数据大批量到过期时间，而查询数据量巨大，引起数据库压力剧增。  
解决方案：   
1.热点数据永不过期  
2.不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。

## 什么是Redis持久化,Redis有哪几种持久化方式,有啥优缺点<span id="什么是Redis持久化"></span>  
Redis持久化就是把内存中的数据写入到磁盘中去，防止服务器宕机导致内存数据丢失。  
Redis提供了两种持久化方式：RDB(Redis DataBase) 和 AOF(Append-only file)。  
### RDB:  
RDB是Redis默认的持久化方式，在指定的时间间隔内将内存中的数据集快照写入磁盘，这种方式是就是将内存中数据以快照（Snapshot）的方式写入到二进制文件（dump.rdb）中   
触发方式：save、bgsave、自动化   
优点：  
1.RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。  
2.RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
缺点：  
当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。  
### AOF:  
全量备份总是耗时的，有时候我们提供一种更加高效的方式AOF，工作机制很简单，redis会将每一个收到的写命令都通过write函数追加到文件中。通俗的理解就是日志记录。  
触发方式：每修改同步（always）、每秒同步（everysec）、不同步（no）  
优点：  
1.AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据  
2.AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。   
缺点：  
对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大   

## 单线程Redis为什么这么快  
1.redis纯内存操作  
2.因为是单线程，所以避免了频繁的上下文切换  
3.采用了非阻塞I/O多路复用机制  

## Memcached与Redis的区别有哪些  
1.Memcached基本只支持简单的key-value存储,Redis还支持list、set、sorted set、hash等众多数据结构  
2.Memcached不支持持久化，Redis支持持久化  
3.由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis  
4.Redis存储value值最大可达512MB，Memcached只有1MB  

## Redis内部数据结构有哪些    
### SDS(Simple Dynamic String，简单动态字符串)  
sds除了用来保存数据库中字符串的值外，还被用作缓冲区，如AOF模块的缓冲区，客户端状态中的输入缓冲区。  
### list(链表)   
list在Redis中运用相当广泛，除了实现列表外，发布和订阅、慢查询、监视器等功能也使用了链表来获取，另外，Redis服务器还使用链表来持有 多个客户端的状态信息，以及用链表来构建客户端输出缓冲区。  
### dict(字典)  
redis数据库就是使用字典作为底层实现的，对数据库的增删查改等操作也是构建在对字典的操作之上。  
### intset(整数集合)  
当一个集合只包含整数值元素，并且这个元素数量不多时，Redis就会使用整数集合作为集合键的底层实现。  
### zskiplist(跳跃表)  
Redis只在两个地方用到了跳跃表，一个是实现有序集合（zset）,另一个是集群节点中用作内部数据结构。  
### ziplist(压缩表)   
压缩表在Redis中的应用只存在于hash和list结构的实现中，为了在存储时节省内存。    

## Redis内存淘汰策略  
Redis4.0以后为我们提供了八个不同的内存置换策略。很早之前提供了6种。  
（1）volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。  
（2）volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。  
（3）volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。  
（4）volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。  
（5）allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。  
（6）allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。  
（7）allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰。  
（8）no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。  

## Redis常见性能问题和解决方案  
(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件
   （Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次）  
(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次(AOF有3种同步方式:1.每秒同步，2.每修改同步，3.不同步)  
(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内  
(4) 尽量避免在压力很大的主库上增加从库







