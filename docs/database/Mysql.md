# Mysql  
1.[MyISAM和InnoDB的区别](#MyISAM和InnoDB的区别)    
2.[事务的隔离级别](#事务的隔离级别)  
2.[Mysql查询语句使用SelectForUpdate导致的数据库死锁分析](#Mysql查询语句使用SelectForUpdate导致的数据库死锁分析)  

## MyISAM和InnoDB的区别  
MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。
5.5 版本之后，MySQL 引入了 InnoDB（事务性数据库引擎），MySQL 5.5 版本后默认的存储引擎为 InnoDB。  
**1.是否支持行级锁**  
MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。
也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！  
**2.是否支持事务**  
MyISAM 不提供事务支持。
InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。  
**3.是否支持外键**  
MyISAM 不支持，而 InnoDB 支持。  
**4.是否支持数据库异常崩溃后的安全恢复**    
MyISAM 不支持，而 InnoDB 支持。
使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 `redo log` 。  
 
🌈 拓展一下：  
- MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。
- MySQL InnoDB 引擎通过 **锁机制**、**MVCC** 等手段来保证事务的隔离性（ 默认支持的隔离级别是 **`REPEATABLE-READ`** ）。
- 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。  
**5.是否支持 MVCC**    
MyISAM 不支持，而 InnoDB 支持。
讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。
MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能。  

## 事务的隔离级别  
●读未提交（Read Uncommitted）  
含义解释：只限制同一数据写事务禁止其他写事务。解决”更新丢失”。（一事务写时禁止其他事务写）  
名称解释：可读取未提交数据  
所需的锁：排他写锁  

●读提交（Read Committed）  
含义解释：只限制同一数据写事务禁止其它读写事务。解决”脏读”，以及”更新丢失”。（一事务写时禁止其他事务读写）  
名称解释：必须提交以后的数据才能被读取  
所需的锁：排他写锁、瞬间共享读锁  

●可重复读（Repeatable Read）  
含义解释：限制同一数据写事务禁止其他读写事务，读事务禁止其它写事务(允许读)。解决”不可重复读”，以及”更新丢失”和”脏读”。（一事务写时禁止其他事务读写、一事务读时禁止其他事务写）  
注意没有解决幻读，解决幻读的方法是增加范围锁（range lock）或者表锁。  
名称解释：能够重复读取  
所需的锁：排他写锁、共享读锁  

●串行化（Serializable）  
含义解释：限制所有读写事务都必须串行化实行。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。（一事务写时禁止其他事务读写、一事务读时禁止其他事务读写）  

## Mysql查询语句使用SelectForUpdate导致的数据库死锁分析  
1.Mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的，根据where条件和select的值是否只有主键或非主键索引来判断怎么锁，比如只有主键，则锁主键索引，如果只有非主键，则锁非主键索引，如果主键非主键都有，则内部会按照顺序锁。   
2.锁相同数据的不同索引条件可能会引起死锁。(一条sql语句先锁主键索引，再锁非主键索引；另外一条sql语句先锁非主键索引，再锁主键索引。虽然两个sql语句期望锁的数据行不一样，但两个sql语句查询或更新的条件或结果字段如果有相同列，则可能会导致互相等待对方锁，2个sql语句即引起了死锁。)    

